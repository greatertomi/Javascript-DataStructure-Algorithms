<html>
  <head>
    <title>Binary Search Tree</title>
  </head>
  <script>
    class Node {
      constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
      }
    }

    class BinarySearchTree {
      constructor() {
        this.root = null;
      }

      insert(value) {
        let newNode = new Node(value);
        if (this.root === null) {
          this.root = newNode;
          return this;
        } else {
          let current = this.root;
          while (true) {
            if (value === current.value) return undefined;
            if (value < current.value) {
              if (current.left === null) {
                current.left = newNode;
                return this;
              }
              current = current.left;
            } else {
              if (current.right === null) {
                current.right = newNode;
                return this;
              }
              current = current.right;
            }
          }
        }
      }

      find(value) {
        if (this.root === null) return false;
        let current = this.root,
          found = false;

        while (current && !found) {
          if (value < current.left) {
            current = current.left;
          } else if (value > current.value) {
            current = current.right;
          } else {
            found = true;
          }
        }
        if (!found) return false;
        return current;
      }

      // Breadth First Search
      BFS() {
        let data = [],
          queue = [];
        let node = this.root;

        queue.push(this.root);
        while (queue.length) {
          node = queue.shift();
          data.push(node.value);
          if (node.left) queue.push(node.left);
          if (node.right) queue.push(node.right);
        }
        return data;
      }

      DFSPreOrder() {
        let data = [];

        const traverse = node => {
          data.push(node.value);
          if (node.left) traverse(node.left);
          if (node.right) traverse(node.right);
        };
        traverse(this.root);
        return data;
      }

      DFSPostOrder() {
        let data = [];

        const traverse = node => {
          if (node.left) traverse(node.left);
          if (node.right) traverse(node.right);
          data.push(node.value);
        };
        traverse(this.root);
        return data;
      }

      DFSInOrder() {
        let data = [];

        const traverse = node => {
          if (node.left) traverse(node.left);
          data.push(node.value);
          if (node.right) traverse(node.right);
        };
        traverse(this.root);
        return data;
      }
    }

    let tree = new BinarySearchTree();
    tree.insert(10);
    tree.insert(15);
    tree.insert(13);
    tree.insert(5);
    tree.insert(9);
    tree.insert(1);
    tree.insert(10);

    // console.log(tree.find(32));
    // console.log(tree.BFS());
    // console.log(tree.DFSPreOrder());
    // console.log(tree.DFSPostOrder());
    console.log(tree.DFSInOrder());
    console.log(tree);
  </script>
</html>
